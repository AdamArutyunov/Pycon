1.

Как известно, олимпиадные программисты сдают свои решения в тестирующие системы. А промышленные программисты эти системы пишут.


2.

Представляю вам Pycon — площадку для тренировок и проведения олимпиад по спортивному программированию на Python. 
Сначала я покажу вам весь Pycon с точки зрения обычного пользователя.


3.

Это — главная страница. На ней размещаются новости.


4.

Итак, главная структурная единица олимпиадного программиста — это задача. Это — страница со всеми задачами. Справа можно увидеть, сколько человек решило задачу.


5.

Если войти в систему, то отмечаются задачи, которые решены, и задачи, которые пользователь пытался решить.


6-7.

Посмотрим на саму задачу. Она состоит из названия, ограничений, условия, входных и выходных данных и примеров.


8.

Естественно, чтобы сдать задачу, нужно зарегистрироваться и войти в систему.


9.

И тут начинается самое интересное. Наше решение отправляется в тестирующую систему, где она прогоняется по всем тестам (об этом — чуть позднее) и выдаёт вердикт. 
На этом скриншоте видны почти все возможные вердикты — ошибка компиляции, ошибка во время исполнения, неправильный ответ, превышение лимита времени и полное решение.
Нет только ошибки ограничения по памяти — и столбец "память" ещё нереализован (inoperative). Время тоже подсчитывается и включается в информацию о посылке.


10.

Можно посмотреть как посылки конкретной задачи, так и все свои посылки.


11.

Следующая важная часть любой площадки для проведения соревнований — контесты. По сути — это набор задач, которые нужно решить в определенный срок. Есть кнопка входа в контест и просмотр положения.


12.

Как только мы войдём в контест, мы будем отображаться в турнирной таблице, а слева от задач появятся статусы их решения.


13.

Положение выглядит классическим образом, но есть небольшой ньюанс.
Сейчас контесты проходят больше по "учебной" форме — во-первых, все задачи, которые отбираются на контест, берутся из общего списка задач, поэтому человек, который решил эти задачи ранее, автоматически получает по ним зачёт.
Во-вторых, не ведётся учёт времени, поэтому в таблице те, кто решил одинаковое количество задач, считаются равнозначными.


14.

Это — взгляд со стороны обычного участника контеста. 
Но, конечно, я разработал набор инструментов, которые видит только администратор и которые позволяют ему удобнее работать с системой.


15.

В меню задач можно удалять задачи и создавать новые.


16.

Задачи создаются с помощью форм, где заполняется условие, ограничения и входные и выходные данные. Редактирование задач входит в ту же форму.


17.

Второе отличие — внизу, в списке задач, помимо редактирования и удаления появляется менеджер тестов. Здесь находятся все тесты, их можно удалять и создавать.


18.

Создание теста — достаточно тривиальная задача — вводятся входные и выходные данные и то, является ли тест примером (то есть, будет ли он отображаться на странице задачи).


19.

В меню контестов также появляется опция удаления и кнопка создания контеста.


20.

В контесте указывается название, дата начала, длительность и то, будут ли скрыты задачи этого контеста до его начала. 
Это нужно для того, чтобы если контест является достаточно серьёзным соревнованием, все были в равных условиях и никто не начал решать задачи до начала контеста.
Редактирование контеста проводится так же.


21.

Ну, и последний админский интерфейс — добавление задачи в контест по его ID.


22.

Итак, моя любимая часть — архитектура. В этот раз мне понадобилось создать всего пять основных моделей.

User — модель пользователя. Включает в себя ID, логин, пароль, e-mail, роль, посылки, задачи, которые он решал, и контесты, в которых он принимает участие.
Problem — модель задачи. В ней есть ID, условие, входные и выходные данные, список тестов (объектов модели Test) и ограничения по времени и памяти.
Submission — модель посылки. Есть ID, посыльщик, задача, пользовательское решение, время посылки, вердикт, промежуточный тест, затраченные время и память.
Test — модель теста. Состоит из ID, номера в задаче (скорее всего, будет ликвидировано), входные и выходные данные, является ли примером и задача, к которой он относится.
Contest — модель контеста. У него есть название, задачи, дата и время начала, длительность и скрытость.

Существуют ещё две вспомогательные модели. Для связи многие-ко-многим обычно делают вспомогательную таблицу ассоциаций, но если в ней нужно хранить помимо ключей ещё какие-то значения, используют модель ассоциации.
В данном случае это UserToProblem (хранит информацию о решенности задачи и количестве посылок) и UserToContest (сейчас не хранит дополнительной информации, раньше хранил количество решённых задач).
Правда, из-за ассоциаций немного усложняется процедура обращения к элементам связи.


Ещё важные замечания по поводу архитектуры:

Множество полей в моделях сделаны с помощью ORM relation, потому что значительно удобнее работать с объектами, а не числами.

В некоторых классах реализованы интерфейсы для удобства и работы с ассоциациями.

Везде в приложении реализована двусторонняя проверка. Не-администратору не будет показываться кнопка удаления задачи, но если он вручную перейдёт по ссылке, ему вернется 403 (Forbidden).
Для удобства я даже написал декоратор admin_required для Flask, который пускает на страницу только администратора.

По сути, приложение можно разделить на два сервиса — один для интерфейса, а другой в отдельном процессе тестирует задачи. Так он и реализован как класс SolutionChecker в отдельном модуле.

В целом, архитектура напоминает модель приложения Model-View-Controller (MVC), где модели обеспечиваются SQLALchemy, контроллер — это Flask, а отображение — шаблонизатор Jinja.


23.

Итак, вот все модули, которые я использовал для приложения.
Flask — веб-сервер, SQLAlchemy — модели, база данных (используется SQLite, но миграция на другую базу в случае необходимости не составит труда).
multiprocessing — для запуска тестирующей системы в отдельном процессе, subprocess для запуска пользовательских решений.
FlaskWTF используется абсолютно во всех формах приложения. FlaskLogin поддерживает систему пользователей.
datetime и time для работы со временем, os для работы с файловой системой, random для работы с энтропией.
Codemirror — библиотека для JS, которая показывает окно для сдачи решений в виде кода. 
functools для создания декоратора, shutil для работы с директориями в тестирующей системе, sys для работы с потоками ввода-вывода.


24.

Больше всего строк, конечно, в HTML (и это с шаблонизатором). Python занимает не так много, потому что это всего лишь контроллер и чекер решений. Ну, и CSS тоже много.
Это, конечно, не так много, как в прошлом проекте (3000 строк и 31 класс против одного), но здесь вся сложность проекта в проектировании баз данных, моделей и соединения различных модулей в одно целое.
Несмотря на то, что здесь не так много строк кода, я считаю это не менее грандиозным архитектурным решением (а прошлый проект я, между прочим, считаю верхом архитектурного шедевра!).

Код красивый и чистый :—).

По сути, использованы две главных технологии — это сам веб и ORM.

Работоспособность проверена недавно и была подкорректирована.


25.

Теперь — о планах. Я не собираюсь оставлять этот проект, а хочу его развивать.

Самые главные направления:
— Уход от учебного олимпиадного программирования в стиле Informatics и переход к более спортивному в стиле CodeForces.
— Реализация работы с памятью (возможно, для этого нужно будет перейти от subprocessing к multiprocessing).
— Полная разработка API.

Ну, и продвижение платформы, создание задач и контестов, разумеется.


26.

Всё.
 